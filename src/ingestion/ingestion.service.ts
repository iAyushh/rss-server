import { BadRequestException, Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { FileService } from '../file/file.service';
import { IngestionDto } from './dto';
import { FILE_TYPE_MIME_MAP } from '../common/constants/file-type-mime.map';
import { FileType } from '@prisma/client';
import * as path from 'node:path';

@Injectable()
export class IngestionService {
  constructor(
    private readonly prisma: PrismaService,
    private readonly fileService: FileService,
  ) {}

  private validateFiles(files: Express.Multer.File[], type: FileType) {
    const allowedMimes = FILE_TYPE_MIME_MAP[type];
    if (!allowedMimes?.length) return;

    for (const file of files) {
      if (!allowedMimes.includes(file.mimetype)) {
        throw new BadRequestException(
          `Invalid file "${file.originalname}" for type ${type}`,
        );
      }
    }
  }

  async ingest(dto: IngestionDto, files: Express.Multer.File[]) {
    const contentType = await this.prisma.contentType.findUnique({
      where: { id: dto.contentTypeId },
    });

    if (!contentType) {
      throw new BadRequestException('Invalid contentTypeId');
    }

    this.validateFiles(files, dto.type);

    // parse metadata
    let metadata: Record<string, string> = {};
    if (dto.metadata) {
      try {
        metadata = JSON.parse(dto.metadata);
      } catch {
        throw new BadRequestException('Invalid metadata JSON');
      }
    }

    // ðŸ”‘ Normalize files (NO disk write here)
    const normalizedFiles = files.map((file) => ({
      displayName: dto.displayName ?? file.originalname,
      description: dto.description,
      originalName: file.originalname,
      storageKey: file.filename, // generated by StorageService
      mimeType: file.mimetype,
      extension: path.extname(file.originalname),
      fileSize: file.size,
      fileType: dto.type,
    }));

    // DB transaction only
    const assets = await this.prisma.$transaction((tx) =>
      this.fileService.attachFiles(
        tx,
        dto.contentTypeId,
        normalizedFiles,
        metadata,
      ),
    );

    return {
      success: true,
      files: assets.map((file) => ({
        id: file.id,
        displayName: file.displayName,
        fileSize: file.fileSize,
        fileType: file.fileType,
        url: this.fileService.getPublicUrl(file.storageKey),
        uploadedAt: file.uploadedAt,
      })),
    };
  }
}
